Mongodb is a document-oriented NoSql (reads not-only-sql) database designed with scalability in mind.  Data in mongodb are stored in BSON (binary JSON) format, and as of version 1.7/1.8, has a limit of 16MB.  This is usually not a issue if you plan to use mongo to store data, but might be limiting if you plan to store binary files.  Luckily, mongodb also offers a way to store large files, using GridFS, which transparently splits the data into chunks.

The Spring-Data-Mongodb project offers a nice high level framework for working with mongodb, which recently released 1.0.1.RELEASE version.

While the MongoTemplate object has yet to offer direct support for GridFS, you can easily get hold of the DB object.  Assuming you have already configured MongoTemplate, you can use it as a factory:

<bean id="gridfsDb" factory-bean="mongoTemplate" factory-method="getDb" />
<bean id="storageService" class="com.rainydayinn.storage.gridfs.StorageServiceGridFSImpl">
 <constructor-arg index="0" name="gridfsDb" ref="gridfsDb" />
</bean>
The service interface:

public interface StorageService {
    String save(InputStream inputStream, String contentType, String filename);
    GridFSDBFile get (String id);
    GridFSDBFile getByFilename (String filename);
}
And the implementation:

public class StorageServiceGridFSImpl implements StorageService {
    private final GridFS gridFs;
 
    public StorageServiceGridFSImpl (DB gridfsDb) {
        gridFs = new GridFS(gridfsDb);
        httpClient = new CommonHttpClient();
    }
 
    @Override
    public String save(InputStream inputStream, String contentType, String filename) {
        GridFSInputFile input = gridFs.createFile(inputStream, filename, true);
        input.setContentType(contentType);
        input.save();
        return input.getId().toString();
    }
 
    @Override
    public GridFSDBFile get(String id) {
        return gridFs.findOne(new ObjectId(id));
    }
 
    @Override
    public GridFSDBFile getByFilename(String filename) {
        return gridFs.findOne(filename);
    }
}
Note that findOne by looks up the file by filename, unless you explicitly call it by ObjectId.

Now throw in an Spring-MVC controller and you got yourself a RESTful service for GridFS

@Controller
@RequestMapping(value = "/storage")
public class StorageController {
    @Autowired
    private StorageService storageService;
 
    @RequestMapping(value = "/id/{id}", method = RequestMethod.GET)
    public void getById (@PathVariable (value="id") String id, HttpServletResponse response) throws IOException {
        StoredFile file = storageService.get(id);
        if (file!=null) {
            byte[] data = IOUtils.toByteArray(file.getInputStream());
            response.setContentType(file.getContenType());
            response.setContentLength((int)file.getLength());
            response.getOutputStream().write(data);
            response.getOutputStream().flush();
        } else {
            response.setStatus(HttpStatus.NOT_FOUND.value());
        }
    }   
 
    @RequestMapping(value = "/store", method = RequestMethod.POST)
    public ResponseEntity<String> store (@RequestParam MultipartFile file, WebRequest webRequest) {
        try {
            String storedId = storageService.save(file.getInputStream(), file.getContentType(), file.getOriginalFilename());
            String storedURL = "/storage/id/" + storedId;
            HttpHeaders responseHeaders = new HttpHeaders();
            responseHeaders.setLocation(location);
            return new ResponseEntity<String>(storedURL, responseHeaders, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<String>(e.getMessage(), new HttpHeaders(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}
Remember to add MultipartResolver some where in your Spring configuration, and you are all set.

1
2
3
4
<bean id="multipartResolver"
class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
<property name="maxUploadSize" value="100000"/>
</bean>
Be Sociable, Share!