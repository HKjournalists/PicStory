Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能. 相比WebService，Hessian更简单、快捷。
采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。

本文将分为以下几个内容：
一、一个简单的Hessian调用例子
二、Spring+Hessian的例子
三、使我们的调用变得通用

第一部分：一个简单的Hessian调用例子
建立web工程HessianService。
这里为了简单起见，我将远程接口类、接口实现类都定义在此web工程下。

个人觉得一个比较好的做法是将web工程分开，此web工程只定义对外的接口并提供服务，而实现类新建一个Java工程存放。
这样web工程依赖此Java工程，且客户端也依赖此Java工程。

1) 远程接口类 ServiceRemote.java

 

package com.al;

import java.util.Map;

@SuppressWarnings("unchecked")
public interface ServiceRemote  {
    public Map callService(Map inputMap) ;
}

2) 实现类 Service.java

package com.al;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("unchecked")
public class Service implements ServiceRemote {

    public Map callService(Map inputMap) {
        if(inputMap == null) {
            inputMap = new HashMap();
        }
        // do something
        // 
        inputMap.put("NAME", "Hessian");
        return inputMap;
    }
}

3) web.xml配置

<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
 http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
    <servlet>
        <servlet-name>hessianService</servlet-name>
        <servlet-class>com.caucho.hessian.server.HessianServlet</servlet-class>
        <init-param>
            <param-name>service-class</param-name>
            <param-value>com.al.Service</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>hessianService</servlet-name>
        <url-pattern>/hessianService</url-pattern>
    </servlet-mapping>
</web-app>

经过以上3步，hessian服务部署算是完成了，在tomcat下发布。

4) 调用方代码

package com.ai.client;

import com.al.ServiceRemote;
import com.caucho.hessian.client.HessianProxyFactory;

public class ClientTest {
    public static void main(String[] args) throws Exception {
        String url = "http://localhost:8080/HessianService/hessianService";
        HessianProxyFactory factory = new HessianProxyFactory();
        ServiceRemote rmt = (ServiceRemote) factory.create(ServiceRemote.class, url);
        System.out.println(rmt.callService(null));
    }
}

执行代码，结果如下：
{NAME=Hessian}
说明调用远程代码成功了。

二、Spring+Hessian的例子
1) web工程HessianService 的ServiceRemote 和Service类不变。对web.xml进行修改：
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/dispatcher-servlet.xml</param-value>
    </context-param>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/remote/*</url-pattern>
    </servlet-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>

这里要注意的是:
a)dispatcher-servlet.xml这个文件的命名。servlet配置为dispatcher，则此文件定义规则为****-servlet.xml.

b)另外就是Spring和hessian的版本问题。
spring版本是2.5.6，需要在此web工程下引入：spring-2.5.6.jar、spring-webmvc-2.5.6.jar、commons-logging-1.1.1.jar。
hessian的版本是hessian-3.1.6.jar，hessian的低版本如 hessian-3.0.13和此Spring版本不合。（我试验了是配置不成功的。）

2) dispatcher-servlet.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
    <description>hessian server properties</description>
    <bean id="serviceImpl" class="com.al.Service" />
    <bean name="/service" class="org.springframework.remoting.caucho.HessianServiceExporter">
        <property name="service">
            <ref bean="serviceImpl" />
        </property>
        <property name="serviceInterface">
            <value>com.al.ServiceRemote</value>
        </property>
    </bean>
</beans>

3) 客户端代码可以保持原样不变，把调用hessian服务的url变换一下即可：
http://localhost:8080/HessianService/remote/service
http://IP:port/发布工程名/web.xml中配置的url-pattern/****-servlet.xml bean的ID。


a.如果hessian服务端我要做的业务很多，怎么办？
我要定义很多个接口，然后再写实现类，最烦的是还要配置它。
我的设想是，hessian服务只提供一个归口，再此对外的接口实现中反射调用具体的业务类。

b.客户端在调用时，每次调用远程接口都要用以下代码吗：

String url = "http://localhost:8080/HessianService/remote/service";
HessianProxyFactory factory = new HessianProxyFactory();
ServiceRemote rmt = (ServiceRemote) factory.create(ServiceRemote.class, url);

显然是不需要的。
我们可以通过加入缓存的方式对其进行改良，我们也可以通过Spring在客户端管理它。

一、完善hessian服务端实现：
1.首先修改ServiceRemote接口：

package com.al;

import java.util.Map;

@SuppressWarnings("unchecked")
public interface ServiceRemote  {
    public Map callService(String target, Map inputMap) throws Exception;
}
callService为统一入口，在此做如下约定：
1)target字符串为要调用的service的完整类路径+要调用的方法。
2)service的方法均用以下方法签名：
public Map ***(Map inputMap);
入参为Map，返回值也为Map，基本可以满足所有情况了。（至少入参为Map，很适合调用iBatis来对DB进行操作。）

2.修改接口实现类Service，此类不做具体业务，而是反射调用具体业务类：
package com.al;

import java.lang.reflect.Method;
import java.util.Map;

import org.apache.commons.beanutils.MethodUtils;
import org.apache.commons.lang.StringUtils;

@SuppressWarnings("unchecked")
public class Service implements ServiceRemote {

    public Map callService(String target, Map inputMap) throws Exception {
        String className = StringUtils.substringBeforeLast(target, ".");
        String methodName = StringUtils.substringAfterLast(target, ".");
        Class serviceClass = loadClass(className);
        Method method = getMethod(serviceClass, methodName, Map.class);
        // 提供访问效率
        method.setAccessible(true);
 // 调用具体业务类
        return (Map) method.invoke(serviceClass.newInstance(), inputMap);
    }
    
    private static <T> Class<T> loadClass(String className) throws ClassNotFoundException {
            return (Class<T>) getClassLoader().loadClass(className);
    }
    
    private static ClassLoader getClassLoader() {
        return Thread.currentThread().getContextClassLoader();
    }
    
    private static Method getMethod(Class<?> cls, String name, Class<?> parameterTypes) {
        return MethodUtils.getAccessibleMethod(cls, name, parameterTypes);
    }
}
 

3.举个例子，服务端提供业务类DisplayUserService.java

package com.al.service;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("unchecked")
public class DisplayUserService {
    public static final String selectUsers = "com.al.service.DisplayUserService.selectUsers";
    public static final String deleteUser = "com.al.service.DisplayUserService.deleteUser";
    
    public Map selectUsers(Map inputMap) {
        Map ret = new HashMap();
        // 数据库操作取得用户列表 省略
        ret.put("User", "User");
        return ret;
    }
    
    public Map deleteUser(Map inputMap) {
        // 数据库操作取得用户列表 省略
        return null;
    }
}

所有其他配置不变，请参考上一篇 Hessian构建分布式系统应用 。


二、客户端代码的修改：
1.加入spring进行管理：
application.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
    <bean id="serviceRemote" class="org.springframework.remoting.caucho.HessianProxyFactoryBean">
        <property name="serviceUrl" value="http://localhost:8080/HessianService/remote/service" />
        <property name="serviceInterface" value="com.al.ServiceRemote" />
    </bean>
</beans>
 

2.客户端如下调用即可：

package com.ai.client;

import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.al.ServiceRemote;
import com.al.service.DisplayUserService;

public class ClientTest {
    public static void main(String[] args) throws Exception {
        ClassPathXmlApplicationContext cxt = new ClassPathXmlApplicationContext("application.xml");
        ServiceRemote rmt = (ServiceRemote)cxt.getBean("serviceRemote");
        System.out.println(rmt.callService(DisplayUserService.selectUsers, null));
    }
}

另外一种方法是自己实现缓存。
也就是第一次调用远程代码时生成ServiceRemote对象，将其保存在静态的容器(HashMap)中，
每次准备调用此远程代码时，先判断容器中是否有ServiceRemote对象，有则直接将其取出并使用即可，要注意的就是在这个容器上的同步问题。
具体实现就不做了，很简单。

在项目中，对于客户端代码来讲，还是有许多工作要做的：
1) 如果我们要调用多个远程服务怎么办？
我们要提供一个统一调用，将远程调用的动作封装起来，让使用的人不知道自己调用了不同的远程服务。
只要调用某个方法、传入参数即可。

2) 如何方便开发员调试远程的服务代码？
在做分布式系统开发的时候，如果每修改一下应用层的service，就要对其进行发布，然后再去调用看是否已OK，那效率会很低。

3) 如何管理多方调用的远程服务？

4) 如何提高远程调用的效率？
是否可以通过对 对象进行缓存、方法是否也可以缓存？甚至是对调用结果进行缓存？

5) 等等..
这些在具体的项目中都是不得不考虑的问题。以后再慢慢讨论吧。

http://wenku.baidu.com/view/6928370f79563c1ec5da719c.html